// Code generated by MockGen. DO NOT EDIT.
// Source: plugin\db\i-factory.go

// Package db is a generated GoMock package.
package db

import (
	identity "github.com/ahl5esoft/lite-go/plugin/db/identity"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockIFactory is a mock of IFactory interface
type MockIFactory struct {
	ctrl     *gomock.Controller
	recorder *MockIFactoryMockRecorder
}

// MockIFactoryMockRecorder is the mock recorder for MockIFactory
type MockIFactoryMockRecorder struct {
	mock *MockIFactory
}

// NewMockIFactory creates a new mock instance
func NewMockIFactory(ctrl *gomock.Controller) *MockIFactory {
	mock := &MockIFactory{ctrl: ctrl}
	mock.recorder = &MockIFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIFactory) EXPECT() *MockIFactoryMockRecorder {
	return m.recorder
}

// Db mocks base method
func (m *MockIFactory) Db(entry identity.IIdentity, extra ...interface{}) IRepository {
	m.ctrl.T.Helper()
	varargs := []interface{}{entry}
	for _, a := range extra {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Db", varargs...)
	ret0, _ := ret[0].(IRepository)
	return ret0
}

// Db indicates an expected call of Db
func (mr *MockIFactoryMockRecorder) Db(entry interface{}, extra ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{entry}, extra...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Db", reflect.TypeOf((*MockIFactory)(nil).Db), varargs...)
}

// Uow mocks base method
func (m *MockIFactory) Uow() IUnitOfWork {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Uow")
	ret0, _ := ret[0].(IUnitOfWork)
	return ret0
}

// Uow indicates an expected call of Uow
func (mr *MockIFactoryMockRecorder) Uow() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Uow", reflect.TypeOf((*MockIFactory)(nil).Uow))
}
